import createDataContext from "./createDataContext";
import loginApi from "../api/login";
import * as WebBrowser from 'expo-web-browser';
import { Buffer } from 'buffer'
import axios from 'axios';
import makeRpCSR from '../server/ServerFacade';
import { sendAuthCSRToCA } from "../server/ServerFacade";
import { decodeVault } from "./AuthContext";
import uuid from 'react-native-uuid';
var forge = require('node-forge');
var pki=forge.pki;


/**
 * RELYING PARTY SUPPORT
 * 
 * LOOK INTO: app linking so if youre on a device to sign into an app, you can click a link that will pull up the authenticator
 * with the session info embedded 
 * 
 * When the landing page scans the qr code on the website, it will either open a new page on the embedded browser or 
 * it will send the sessionID, Domain, and method to the app
 *  
 * DONE- CHECK W JOEL
 * The app will call the CA with a Certificate Signing Request, containing the accountID*, and K_Account*. 
 * It will be signed with S_Auth and sent with a copy of the authenticator's cert.
 * Also will pass the Authenticators Certificate
 * 
 * -* The accountID, K_Account, and S_Account will be generated by the Authenticator app when first registered with the RP
 * 
 * CA RESPONSE: CA will now associate the accountID used with the username. Returns an account certificate listing the accountID and K_Account
 * 
 * ACCOUNT CERTIFICATE: Lifetime of about a minute, just long enough for login
 * 
 * 
 * OBTAINNING A SESSION CERTIFICATE: Get a session cert to authorize login for a given session(identified by sessionID). 
 * The authenticator will generatethis session cert and sign it. Cert
 * contains: sessionID, domain name of RP,and K_Session for the relying party. Signed by S_Account
 * 
 * AUTH RESPONSE TO RP: Sends the auth certificate, session cert, and a signature of the sessionID
 * 
 * LOGGING IN: authenticator looks up the K_Session that is uses for the relying party. 
 * The mapping is only accessible to the authenticator and is encrypted when stored. It proves it 
 * owns S_Session by signing the SessionID in order to login
 */

 const rpReducer = (state,action) => {
    switch (action.type) {
        case 'place_holder':
            return {...state, errorMessage: action.payload};
        case 'clear_error_message':
            return { ...state, errorMessage: '' }    
        default:
            return state;
    }
};
const clearErrorMessage = dispatch => () => {
    //clean error message state
    dispatch({ type: 'clear_error_message' });
};
//TODO: implement rp method: just a string that will tell if its register or login
const rpRegister = (dispatch) => {
    return async ( { sessionID, rpDomain, rpMethod } ) => {
        try{
            if(rpMethod == 'login'){

            }
            else if(rpMethod == 'register'){
                
            }
            let accountID = uuid.v4();
            let accKeys = pki.rsa.generateKeyPair(2048);
            let s_Account = accKeys.privateKey;
            let k_Account = accKeys.publicKey;
            //let vaultString = await AsyncStorage.getItem('vault');
            //let vault = decodeVault(vaultString);
            let s_Auth = 1234;//vault.authKeyPrivate;
            let k_Auth = 12345//vault.authKeyPublic;
            let authCert = "asdf";//await AsyncStorage.getItem('authCert');
            let csr = makeRpCSR(accountID, s_Account, k_Account);
            var sigForCA = ED25519.sign({
                message: csr,
                // also accepts `binary` if you want to pass a binary string
                encoding: 'utf8',
                // node.js Buffer, Uint8Array, forge ByteBuffer, binary string
                privateKey: s_Auth
            });
            let accountCert = await sendAccountCSRToCA(authCert, csr, sigForCA); //accountCert lists the accountID and K_Account. Lifetime is about 1 minute
            let sessionCert = createSessionCert(sessionID, rpDomain, k_Session, accKeys.privateKey, k_Account);
            var signature = ED25519.sign({
              message: sessionID,
              // also accepts `binary` if you want to pass a binary string
              encoding: 'utf8',
              // node.js Buffer, Uint8Array, forge ByteBuffer, binary string
              privateKey: s_Auth
            });
            let response = await axios.post(
                'URL HERE' + accountCert, sessionCert, signature
             );
            //then logs on by looking up k_session? Maybe some endpoint it can call for this, passing in k_session. Then needs to sign sessionID.
        }
        catch (err) {
            dispatch({ type: 'add_error', payload: 'Something went wrong when registering with Relying Party'});
            console.log(err.response.data);
        }

    };
};


/* OBTAINNING A SESSION CERTIFICATE: Get a session cert to authorize login for a given session(identified by sessionID). 
 * The authenticator will generatethis session cert and sign it. Cert
 * contains: sessionID, domain name of RP,and K_Session for the relying party. Signed by S_Account
 */
const createSessionCert = (sessionID, domainN, k_Session, s_Account, k_Account) => {
    //Creates sessionCert
    var cert = pki.createCertificate();
    cert.publicKey = k_Account;
    cert.serialNumber = '01';
    cert.validity.notBefore = new Date();
    cert.validity.notAfter = new Date();
    cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);
    var attrs = [{
        name: 'sessionID',
        value: sessionID
    }, {
        name: 'domain',
        value: domainN
    }, {
        shortName: 'k_Session',
        value: k_Session
    }];
    cert.setSubject(attrs);
  // alternatively set subject from a csr
  //cert.setSubject(csr.subject.attributes);
    cert.setIssuer(attrs);

// self-sign certificate
    cert.sign(s_Account);

// convert a Forge certificate to PEM
  //var pem = pki.certificateToPem(cert);

}


 export const { Provider, Context } = createDataContext(
    rpReducer,
    { clearErrorMessage },
    { errorMessage:'', }
);
